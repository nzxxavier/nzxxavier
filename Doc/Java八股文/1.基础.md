# 1.ArrayList和Vector的差别
* 同步性：ArrayList线程不同步，Vector线程同步，故Vector线程安全，ArrayList不安全
* 容量增长：ArrayList扩容0.5倍，Vector扩容1倍，且Vector可以设置每次增长的空间大小
# 2.HashMap和Hashtable的区别
* 同步性：HashMap线程不同步，Hashtable线程同步，故HashMap线程安全，Hashtable不安全，但是现在一般使用ConcurrentHashMap作为Hashtable的替代
* 运算：HashMap允许空键
# 3.ConcurrentHashMap相比Hashtable改进了哪些东西
1. 同步性：Hashtable为对象锁，而ConcurrentHashMap实现了更细粒度的锁
2. 并发性：Hashtable由于锁对象，且读也加锁，故并发性能比较差
3. 迭代器：Hashtable在使用迭代器的同时被修改会抛出异常，而ConcurrentHashMap不会
4. 数据结构：ConcurrentHashMap在链表过长（默认值8）的情况下会转化为红黑树，Hashtable不会
# 4.JDK运维工具

* jstack：生成当前线程快照
* jstat：JVM运行时信息，包括GC（各区容量/用量，GC时间等）、类加载、JIT编译等
* jmap：生成堆快照
* jhat：快速分析堆Dump，查看对象数量、引用关系等
# 5.GC的原理是啥
1. 引用计数法：每个对象都有引用计数，但是解决不了循环引用，故主流JVM都不用这种算法
2. 可达性分析算法：使用一系列树型数据结构，对于对象来说，只要从GC Roots到对象没有链路则认为需要清理
	* 虚拟机栈
	* 方法区类静态属性
	* 方法区常量
	* 方法区中JNI（Native方法）引用的对象
# 6.GC的主要算法

* 标记-清除算法：分为“标记”和“清除”两个阶段。首先标记出所有需要回收的对象，在**标记完成后统一回收所有被标记的对象**，缺点是效率低且会产生很多内存碎片
* 复制算法：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象**复制**到另外一块上面，然后**再把已使用过的内存空间一次清理掉**，缺点是浪费内存，一般用于**新生代**
* 标记-整理算法：与清除算法的差别是**会把内存中的对象都向一端移动**，然后直接清理掉端边界以外的内存，缺点是在GC时需要暂停用户程序，一般用于**老年代**
* 分代收集算法：主流JVM都用这种算法，**新生代-复制算法**，**老年代-标记-整理算法**
# 7.堆内存模型
* 新生代：根据复制算法设计的模型
	* Eden区：新对象都分配在Eden区，Eden区满之后触发**Minor GC**
	* FromSurvivor区和ToSurvivor区：**两个Survivor区来回倒腾数据**，每次触发Minor GC都会将Eden区和当前使用的Survivor区（即FromSurvivor区）遗留的对象挪到即将使用的Survivor区（即ToSurvivor区），每次挪到ToSurvivor区的对象年龄都+1
* 老生带：根据标记-整理算法设计的模型，老年代空间不足或方法区空间不足时触发**Major GC**，将年龄超过阈值的新生代对象移动到老生带并整理内存空间，速度比Minor GC慢10倍以上
# 8.主要垃圾收集器
* JDK8
	* ParNew：多线程复制收集器，需要停止用户线程
	* CMS：多线程标记-整理收集器
* JDK9以后：
	* G1收集器：不需要多种收集器了，分区数量不在固定（4个），而是有多个分区，每个分区仍然具有Eden、Survivor 或 Old 区域中的一种角色类型
	* **ZGC**：超大堆使用，停顿时间短且不随堆大小增长