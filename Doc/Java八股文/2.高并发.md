# 1. 什么是CAS
Compare And Swap，先比较再交换，硬件级原子操作，用于保证内存的读-改-写操作的原子性。
# 2. CAS操作面临的问题
1. ABA问题：即某个值先改为B再改为A，对于CAS机制来说无法识别。JDK提供了某种机制，除了检查值以外还检查版本号
2. 自旋问题：资源竞争非常激烈时会不定的CAS
3. 只能保证单个变量的原子性：同时对多个变量操作时用不了CAS，只能手动加锁控制
# 3. 原子类
使用CAS机制包装的类，对其操作都是原子性的，保证线程安全
# 4. volatile关键字含义
* 可见性：即用volatile关键字修饰的变量无法被线程缓存
* 禁止指令重排序：即对volatile关键字修饰的变量的操作无法被编译器和处理器重排序，双重检查锁需要用到这个机制，保证其他线程访问这个单例对象时一定是已经初始化好的
* 不保证原子性：本身和原子操作也没啥关系
# 5. ThreadLocal内存泄漏的原因
* ThreadLocal对象内部通过ThreadLocal.ThreadLocalMap类型的对象存储数据
* ThreadLocal.ThreadLocalMap的key是弱引用，value是强引用
* **key是弱引用，会被GC回收**
* 回收以后这个Entry的key为null了，但是由于value是强引用，故不会被回收
* 所以只要这个ThreadLocal.ThreadLocalMap不被回收（即Entry不被回收），这个value永远不会被回收
* 虽然只要线程被回收了，ThreadLocal.ThreadLocalMap也会被回收，但是若这个线程永远不被回收（线程池场景），那么这个ThreadLocal.ThreadLocalMap就会越来越大